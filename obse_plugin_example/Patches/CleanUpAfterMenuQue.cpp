#include "CleanUpAfterMenuQue.h"

#include <array>
#include "obse_common/SafeWrite.h"
#include "shared.h"

#include "obse/GameTiles.h"
#include "ReverseEngineered/NetImmerse/NiTypes.h"
#include "ReverseEngineered/UI/Menu.h"
#include "ReverseEngineered/UI/Tile.h"
#include "Services/PatchManagement.h"

#include "Patches/TagIDs/Main.h"

#include "Miscellaneous/strings.h"
#include "Fun/x86Reader.h"

MenuQueState g_menuQue;

namespace CobbPatches {
   namespace CleanUpAfterMenuQue {
      namespace MenuQueReverseEngineered {
         //
         // Information about MenuQue gleaned from disassembly; retained just so 
         // I can make enough sense of what it's doing to investigate conflicts.
         //
         struct UnkMenu { // sizeof == 0x34
            const char* menuName; // 00
            UInt32      menuID;   // 04
            UInt32      unk08;    // 08
            void*       menuVtbl; // 0C
            UInt32 unk10;
            UInt32 unk14;
            void*  unk18; // 18 // stores pointer to Menu::HandleFrame (for subclass) after patching the VTBL
            void*  unk1C; // 1C // subroutine pointer; possibly ShowGenericMenu et. al
            void*  unk20; // 20 // subroutine pointer; for GenericMenu, it's a vanilla no-op
            void*  unk24; // 24 // subroutine pointer; for GenericMenu, it's a vanilla no-op
            void*  unk28; // 28 // stores pointer to Menu::HandleFrameMouseDown (for subclass) after patching the VTBL
            void*  unk2C; // 2C // stores pointer to Menu::HandleKeyboardInput  (for subclass) after patching the VTBL
            void*  unk30; // 30 // Menu*; only defined for HUDMainMenu?

            void UnkApplyPatch(UInt32 unkOffset, UInt32 subroutinePointer);
         };
         //
         // KNOWN MENUQUE PATCH SITES NOT CLEANED UP BY US:
         //  - 0x00403F60 - Patches Singleton00B33398::InputManager::RebindControl.
         //  - 0x0057CEE0 - Patches the very start of InterfaceMenu::ForceCloseAllActiveMenus.
         //  - 0x00582547 - NOPs several instructions in InterfaceManager::Update, with the apparent intention of allowing tiles without IDs to send mouse-up events.
         //  - 0x0058391E - Patches InterfaceManager::Update, with the apparent intention of forcing code that forwards an exit-button click to LoadgameMenu to send the tile pointer rather than just ID#1 and nullptr.
         //  - 0x00585330 - Patches Menu::~Menu.
         //  - 0x00589636 - Fixes the default message duration for messages generated by QueueUIMessage.
         //  - 0x0058B039 - Patches the very end of Tile::DefineTileValuesAndTraits in order to define MenuQue traits.
         //  - 0x0058B86D - Replaces all behavior for the parent() selector.
         //  - 0x0058C01A - Patches Tile::Value::DoActionEnumeration.
         //  - 0x0058D1AC - Patches the very end of Tile::UpdateTemplatedChildren.
         //  - 0x0058DA77 - Patches Tile::Subroutine0058DA70.
         //  - 0x00590330 - Patches the very start of Tile::CreateTemplatedChildren.
         //  - 0x005910AC - One of eight patch sites apparently used to allow case-insensitive texture paths in menus.
         //  - 0x005910DC - One of eight patch sites apparently used to allow case-insensitive texture paths in menus.
         //  - 0x0059110C - One of eight patch sites apparently used to allow case-insensitive texture paths in menus.
         //  - 0x0059113C - One of eight patch sites apparently used to allow case-insensitive texture paths in menus.
         //  - 0x00591169 - One of eight patch sites apparently used to allow case-insensitive texture paths in menus.
         //  - 0x00591196 - One of eight patch sites apparently used to allow case-insensitive texture paths in menus.
         //  - 0x005911D2 - One of eight patch sites apparently used to allow case-insensitive texture paths in menus.
         //  - 0x005AD853 - One of eight patch sites apparently used to allow case-insensitive texture paths in menus. This appears to be a special case for loading screens.
         //  - 0x00591BAF - Patches TileMenu::~TileMenu.
         //  - 0x00593365 - Patches the subroutine that closes AlchemyMenu    and returns control to the Big Four.
         //  - 0x0059BBE9 - Unknown patch apparently related to the ControlsMenu.
         //  - 0x005CEA14 - Patches the subroutine that closes RechargeMenu   and returns control to the Big Four.
         //  - 0x005D041A - Patches the subroutine that closes RepairMenu     and returns control to the Big Four.
         //  - 0x005D4250 - Patches the subroutine that closes SigilStoneMenu and returns control to the Big Four.
         //  - 0x005FB41C - Patches the subroutine that calls ShowAlchemyMenu.
         //  - 0x005FB586 - Patches the subroutine that calls ShowSigilStoneMenu.
         //  - 0x005FB615 - Patches what appears to be an InventoryMenu handler for opening RechargeMenu from a soul gem.
         //  - 0x005FB6D1 - Patches the subroutine that calls ShowRepairMenuAsSubmenu.
         //  - Parts of the jump table at 0x0058BAB4: cases 0x138B (???) and 0x138F (strings).
         //
      };

      namespace MenuQueFixes {
         //
         // One of MenuQue's patches crashes when menus with extended IDs are open, 
         // and we can't reasonably stop it from running into that case. The only 
         // option is to patch MenuQue itself.
         //
         // The problem occurs in a hook that MenuQue applies to the interface's 
         // frame handler, to operate on the mouseTarget tile. MenuQue tries to 
         // retrieve a TileLink (a new Tile subclass) and then call a method on 
         // it. If the TileLink is nullptr, MenuQue crashes, because there's no 
         // check for that. The pointer will be null if the mouseTarget belongs to 
         // a menu with an extended ID, or if the mouseTarget belongs to a menu 
         // that is not the InterfaceManager::activeMenu.
         //
         // The solution is to patch this TileLink method to check whether the 
         // this pointer is null.
         //
         struct Patch {
            const char* version;
            UInt32 hookTarget; // where does the hook jump to?
            //
            UInt32 patchSubroutine;
            UInt32 patchOffset;
            UInt32 returnFailOffset;
            UInt32 returnPassOffset;
         };
         namespace Recognition {
            //
            // functions for finding the target subroutine and patch offsets across different MenuQue versions
            //
            //  - name after the oldest version it would match
            //
            void v16a(UInt32 hookTargetAddr, Patch& out) {
               try {
                  UInt32 caller = 0;
                  UInt32 target = 0;
                  {  // Parse the entire hook.
                     x86Reader reader(hookTargetAddr);
                     reader.PUSH(x86Reader::ebx);
                     caller = reader.CallToAnyAddress();
                     reader.ADD(x86Reader::esp, (UInt8)4);
                     reader.CMP<UInt8>(x86Reader::esp, x86Reader::edi, 0x48);
                     reader.JE<SInt8>(0x06);
                     reader.JumpThroughAnyStatic();
                     reader.JumpThroughAnyStatic();
                  }
                  {  // Parse the immediate caller to KYO::TileLink::UnnamedMember, to make sure it's roughly the same and not just coincidentally similar.
                     x86Reader reader(caller + (UInt32)0x8D);
                     reader.PUSH(x86Reader::eax);
                     reader.CallToAnyAddress(); // returns KYO::TileLink given class KYO::TileLink : public Tile.
                     reader.ADD(x86Reader::esp, (UInt8)0x8);
                     reader.PUSH(x86Reader::ebx);
                     reader.MOV(x86Reader::ecx, x86Reader::eax);
                     target = reader.CallToAnyAddress();
                     reader.POP(x86Reader::edi);
                     reader.POP(x86Reader::esi);
                     reader.POP(x86Reader::ebx);
                     reader.POP(x86Reader::ebp);
                     reader.RETN();
                  }
                  {  // Parse KYO::TileLink::UnnamedMember.
                     x86Reader reader(target);
                     reader.PUSH(x86Reader::ebp);
                     reader.MOV(x86Reader::ebp, x86Reader::esp);
                     reader.PUSH(x86Reader::ecx);
                     reader.MOV <UInt8>(x86Reader::eax, x86Reader::ebp, 8);
                     reader.PUSH(x86Reader::ebx);
                     reader.MOV(x86Reader::ebx, x86Reader::ecx);
                     reader.CMP <UInt8>(x86Reader::ebx, x86Reader::eax, 0x40);
                     reader.JNE <SInt8>(0x09);
                     //
                     out.version = "16a-like";
                     out.hookTarget = hookTargetAddr - g_menuQue.addrBase;
                     out.patchSubroutine  = target - g_menuQue.addrBase;
                     out.patchOffset      = 0x0A;
                     out.returnFailOffset = 0x0F;
                     out.returnPassOffset = 0x18;
                  }
               } catch (std::runtime_error) {};
               out.version = "";
               out.hookTarget = 0;
               out.patchSubroutine = 0;
               out.patchOffset = 0;
               out.returnFailOffset = 0;
               out.returnPassOffset = 0;
            };
         };
         const Patch knownVersions[] = {
            { "16a", 0x00011A50, 0x000145C0, 0xA, 0xF, 0x18 },
            { "16b", 0x00011E30, 0x00014860, 0xA, 0xF, 0x18 },
         };

         //
         static UInt32 s_mqReturnFail    = 0;
         static UInt32 s_mqReturnProceed = 0;
         __declspec(naked) void Outer() {
            _asm {
               test ebx, ebx;
               jz   lFail;
               cmp  dword ptr [ebx + 0x40], eax;
               je   lFail;
               mov  eax, s_mqReturnProceed;
               jmp  eax;
            lFail:
               mov  eax, s_mqReturnFail;
               jmp  eax;
            };
         };
         void Apply() {
            if (!g_menuQue.detected)
               return;
            if (!g_menuQue.addrBase) {
               _MESSAGE(" - MenuQue's base address is missing. Unable to apply safety patches; attempting to open menus with extended IDs will crash due to missing nullptr checks in MenuQue.");
               return;
            }
            if (*(UInt8*)(0x0058251B) != 0xE9) // check for patched-in JMP
               return;
            _MESSAGE(" - Detected hook to InterfaceManager::Update+0x32B. Checking to see if it's a known MenuQue hook.");
            UInt32 jumpAbs = *(UInt32*)(0x0058251C) + 0x0058251C + sizeof(void*);
            UInt32 jumpRel = jumpAbs - g_menuQue.addrBase;
            //
            for (auto i = 0; i < std::extent<decltype(knownVersions)>::value; i++) {
               auto& p = knownVersions[i];
               if (jumpRel == p.hookTarget) {
                  s_mqReturnFail    = g_menuQue.addrBase + p.patchSubroutine + p.returnFailOffset;
                  s_mqReturnProceed = g_menuQue.addrBase + p.patchSubroutine + p.returnPassOffset;
                  UInt32 target     = g_menuQue.addrBase + p.patchSubroutine + p.patchOffset;
                  WriteRelJump(target, (UInt32)&Outer);
                  _MESSAGE("    - Patched successfully applied to MQ:0x%08X per data for known MenuQue version %s.", target - g_menuQue.addrBase, p.version);
                  return;
               }
            }
            //
            // Patch isn't known. See if we can recognize it by its compiled code.
            //
            if (g_menuQue.addrSize && jumpAbs < g_menuQue.addrBase + g_menuQue.addrSize) {
               _MESSAGE("    - Not a known MenuQue hook. Jump target read as MQ_%08X (%08X).", jumpRel, jumpAbs);
            } else {
               _MESSAGE("    - Not a MenuQue hook. Jump target read as %08X.", jumpAbs);
            }
            Patch recognized;
            Recognition::v16a(jumpAbs, recognized);
            if (recognized.patchSubroutine) {
               s_mqReturnFail    = g_menuQue.addrBase + recognized.patchSubroutine + recognized.returnFailOffset;
               s_mqReturnProceed = g_menuQue.addrBase + recognized.patchSubroutine + recognized.returnPassOffset;
               UInt32 target     = g_menuQue.addrBase + recognized.patchSubroutine + recognized.patchOffset;
               WriteRelJump(target, (UInt32)&Outer);
               _MESSAGE("    - MenuQue hook has identical content to a known version (%s). Patch successfully applied to MQ:0x%08X.", recognized.version, target - g_menuQue.addrBase);
               return;
            }
            _MESSAGE("    - Unable to recognize hook site, hook callee, or patch site. Failed to apply our fix.");
            g_menuQue.newMenuIDFixFailed = true;
         };
      };

      struct Call {
         UInt32 address = 0;
         UInt8  brokenByteCount = 0;
         //
         Call(UInt32 a, UInt8 b) : address(a), brokenByteCount(b) {};
      };

      const Call calls[] =
         {
            //
            // These should be: the address of the patched in call or jump itself; followed by the 
            // number of NOPs needed after the call or jump.
            //
            {0x00576567,  2}, // FontManager::FontManager
            {0x0057FEF7, 10}, // possibly MenuTextInputState::~MenuTextInputState
            {0x0057FF50,  1}, // MenuTextInputState::HandleKeypress
            {0x00580120,  1}, // MenuTextInputState::Subroutine00580120
            {0x0058251B,  5}, // InterfaceManager::Update
            {0x00583A4B,  3}, // InterfaceManager::Update
            {0x00583AE3,  3}, // InterfaceManager::Update
            {0x00583B59,  1}, // InterfaceManager::Update
            {0x00583C41,  2}, // InterfaceManager::UpdateAndExpireFadeTimers
            {0x0058430B,  2}, // FadeMenu
            {0x00584960,  1}, // Menu::Subroutine00584960
            {0x00585190,  1}, // Menu::EnableMenu
            {0x005866CC,  1}, // unknown; this is the subroutine that handles "reload [MenuName]" console commands
            {0x00589C27,  1}, // Tile::Value::~Value              // related to operators?
            {0x0058BF92,  1}, // Tile::Value::DoActionEnumeration
            {0x0058BFBC,  1}, // Tile::Value::DoActionEnumeration
            {0x0058C04C,  2}, // Tile::Value::DoActionEnumeration
            {0x0058C33E,  5}, // Tile::Value::DoActionEnumeration
            {0x0058C798,  1}, // Tile::Value::DoActionEnumeration
            {0x0058C7BA,  1}, // Tile::Value::DoActionEnumeration
            {0x0058C85F,  1}, // Tile::Value::DoActionEnumeration
            {0x0058CF66,  1}, // Tile::UpdateTemplatedChildren
            {0x0058D0F8,  1}, // Tile::UpdateTemplatedChildren
            {0x0058D1AC,  5}, // Tile::UpdateTemplatedChildren
            {0x0058D2F0,  2}, // Struct0058BCD0::AddTemplateItem
            {0x0058DC7C,  1}, // ParseXML
            {0x005A40D0,  1}, // unknown; likely ShowGenericMenu; definitely related to GenericMenu
            {0x005A68FF,  2}, // unknown; related to the Big Four; likely handles the switch to StatsMenu
         };

      bool GetMQModuleBaseFromWinAPI() {
         constexpr int LOAD_COUNT = 140;
         HANDLE  processHandle = GetCurrentProcess();
         HMODULE modules[LOAD_COUNT];
         DWORD   bytesNeeded;
         if (!EnumProcessModules(processHandle, modules, sizeof(modules), &bytesNeeded))
            return false;
         bool   overflow = bytesNeeded > (LOAD_COUNT * sizeof(HMODULE));
         UInt32 count = (std::min)(bytesNeeded / sizeof(HMODULE), (UInt32)LOAD_COUNT);
         //
         std::string path;
         for (UInt32 i = 0; i < count; i++) {
            TCHAR szModName[MAX_PATH];
            if (!GetModuleFileNameEx(processHandle, modules[i], szModName, sizeof(szModName) / sizeof(TCHAR)))
               continue;
            path = szModName;
            if (cobb::striendswith(path, "data\\obse\\plugins\\menuque\\submodule.game.dll")) {
               MODULEINFO moduleData;
               if (!GetModuleInformation(processHandle, modules[i], &moduleData, sizeof(moduleData))) {
                  g_menuQue.addrBase = (UInt32) modules[i]; // we still have the module base
                  g_menuQue.addrSize = 0;
                  return true;
               }
               g_menuQue.addrBase = (UInt32) moduleData.lpBaseOfDll;
               g_menuQue.addrSize = moduleData.SizeOfImage;
               return true;
            }
         }
         return false;
      };
      void Apply() {
         _MESSAGE("Cleaning up after MenuQue patches... (Some leave broken bytes, which is harmless but will confuse a disassembler.)");
         for (UInt32 i = 0; i < std::extent<decltype(calls)>::value; i++) {
            UInt32 address = calls[i].address;
            char opcode = *(char*) address;
            if (opcode != (char) 0xE8 && opcode != (char) 0xE9) { // comparing without a cast compares as a UInt32, fucking hell
               _MESSAGE(" - MenuQue has not patched address %08X (detected opcode is %02X). Leaving it alone.", address, opcode);
               continue;
            }
            _MESSAGE(" - Writing NOPs near address %08X.", address);
            address += 5;
            UInt8 count = calls[i].brokenByteCount;
            SafeMemset(address, 0x90, count);
            g_menuQue.detected = true;
         }
         _MESSAGE(" - All known patches have been looked at.");
         //
         // Get the module base.
         //
         if (GetMQModuleBaseFromWinAPI()) {
            _MESSAGE(" - MenuQue's base address reads as %08X (size %08X) based on Windows APIs.", g_menuQue.addrBase, g_menuQue.addrSize);
         } else {
            _MESSAGE(" - Unable to identify MenuQue's base address using Windows APIs (too many modules loaded?). Will try the ugly method, which is only reliable for MenuQue v16b.");
            UInt32 callFrom = 0x0058BFBC;
            if (*(char*)callFrom == (char)0xE9) {
               UInt32 a = *(UInt32*)(callFrom + 1);
               UInt32 t = a + callFrom + 1 + 4;
               g_menuQue.addrBase = t - 0x00012040;
               _MESSAGE(" - MenuQue's base address reads as %08X based on the patch to %08X.", g_menuQue.addrBase, callFrom);
            } else if (g_menuQue.detected)
               _MESSAGE(" - Unable to identify MenuQue's base address! Some of our compatibility patches will not function!");
         }
         //
         // Apply any other fixes.
         //
         MenuQueFixes::Apply();
         PatchManager::GetInstance().FireEvent(PatchManager::Req::P_MenuQue); // fire any other patches that were waiting on us
      }
   }
}