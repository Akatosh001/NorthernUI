#include "CleanUpAfterMenuQue.h"

#include <array>
#include "obse_common/SafeWrite.h"
#include "shared.h"

#include "obse/GameTiles.h"
#include "ReverseEngineered/NetImmerse/NiTypes.h"
#include "ReverseEngineered/UI/Tile.h"

#include "Patches/TagIDs/Main.h"

extern bool   g_detectedMenuQue = false;
extern UInt32 g_detectedMenuQueBaseAddress = 0;

namespace CobbPatches {
   namespace CleanUpAfterMenuQue {
      namespace MenuQueReverseEngineered {
         //
         // Information about MenuQue gleaned from disassembly; retained just so 
         // I can make enough sense of what it's doing to investigate conflicts.
         //
         struct UnkMenu { // sizeof == 0x34
            const char* menuName; // 00
            UInt32      menuID;   // 04
            UInt32      unk08;    // 08
            void*       menuVtbl; // 0C
            UInt32 unk10;
            UInt32 unk14;
            void*  unk18; // 18 // stores pointer to Menu::HandleFrame (for subclass) after patching the VTBL
            void*  unk1C; // 1C // subroutine pointer; possibly ShowGenericMenu et. al
            void*  unk20; // 20 // subroutine pointer; for GenericMenu, it's a vanilla no-op
            void*  unk24; // 24 // subroutine pointer; for GenericMenu, it's a vanilla no-op
            void*  unk28; // 28 // stores pointer to Menu::HandleFrameMouseDown (for subclass) after patching the VTBL
            void*  unk2C; // 2C // stores pointer to Menu::HandleKeyboardInput  (for subclass) after patching the VTBL
            void*  unk30; // 30 // Menu*; only defined for HUDMainMenu?

            void UnkApplyPatch(UInt32 unkOffset, UInt32 subroutinePointer);
         };
         //
         // KNOWN MENUQUE PATCH SITES NOT CLEANED UP BY US:
         //  - 0x00403F60 - Patches Singleton00B33398::InputManager::RebindControl.
         //  - 0x0057CEE0 - Patches the very start of InterfaceMenu::ForceCloseAllActiveMenus.
         //  - 0x00582547 - NOPs several instructions in InterfaceManager::Update, with the apparent intention of allowing tiles without IDs to send mouse-up events.
         //  - 0x0058391E - Patches InterfaceManager::Update, with the apparent intention of forcing code that forwards an exit-button click to LoadgameMenu to send the tile pointer rather than just ID#1 and nullptr.
         //  - 0x00585330 - Patches Menu::~Menu.
         //  - 0x00589636 - Fixes the default message duration for messages generated by QueueUIMessage.
         //  - 0x0058B039 - Patches the very end of Tile::DefineTileValuesAndTraits in order to define MenuQue traits.
         //  - 0x0058B86D - Replaces all behavior for the parent() selector.
         //  - 0x0058C01A - Patches Tile::Value::DoActionEnumeration.
         //  - 0x0058D1AC - Patches the very end of Tile::UpdateTemplatedChildren.
         //  - 0x0058DA77 - Patches Tile::Subroutine0058DA70.
         //  - 0x00590330 - Patches the very start of Tile::CreateTemplatedChildren.
         //  - 0x005910AC - One of eight patch sites apparently used to allow case-insensitive texture paths in menus.
         //  - 0x005910DC - One of eight patch sites apparently used to allow case-insensitive texture paths in menus.
         //  - 0x0059110C - One of eight patch sites apparently used to allow case-insensitive texture paths in menus.
         //  - 0x0059113C - One of eight patch sites apparently used to allow case-insensitive texture paths in menus.
         //  - 0x00591169 - One of eight patch sites apparently used to allow case-insensitive texture paths in menus.
         //  - 0x00591196 - One of eight patch sites apparently used to allow case-insensitive texture paths in menus.
         //  - 0x005911D2 - One of eight patch sites apparently used to allow case-insensitive texture paths in menus.
         //  - 0x005AD853 - One of eight patch sites apparently used to allow case-insensitive texture paths in menus. This appears to be a special case for loading screens.
         //  - 0x00591BAF - Patches TileMenu::~TileMenu.
         //  - 0x00593365 - Patches the subroutine that closes AlchemyMenu    and returns control to the Big Four.
         //  - 0x0059BBE9 - Unknown patch apparently related to the ControlsMenu.
         //  - 0x005CEA14 - Patches the subroutine that closes RechargeMenu   and returns control to the Big Four.
         //  - 0x005D041A - Patches the subroutine that closes RepairMenu     and returns control to the Big Four.
         //  - 0x005D4250 - Patches the subroutine that closes SigilStoneMenu and returns control to the Big Four.
         //  - 0x005FB41C - Patches the subroutine that calls ShowAlchemyMenu.
         //  - 0x005FB586 - Patches the subroutine that calls ShowSigilStoneMenu.
         //  - 0x005FB615 - Patches what appears to be an InventoryMenu handler for opening RechargeMenu from a soul gem.
         //  - 0x005FB6D1 - Patches the subroutine that calls ShowRepairMenuAsSubmenu.
         //  - Parts of the jump table at 0x0058BAB4: cases 0x138B (???) and 0x138F (strings).
         //
      };

      struct Call {
         UInt32 address = 0;
         UInt8  brokenByteCount = 0;
         //
         Call(UInt32 a, UInt8 b) : address(a), brokenByteCount(b) {};
      };

      const Call calls[] =
         {
            //
            // These should be: the address of the patched in call or jump itself; followed by the 
            // number of NOPs needed after the call or jump.
            //
            {0x00576567,  2}, // FontManager::FontManager
            {0x0057FEF7, 10}, // possibly MenuTextInputState::~MenuTextInputState
            {0x0057FF50,  1}, // MenuTextInputState::HandleKeypress
            {0x00580120,  1}, // MenuTextInputState::Subroutine00580120
            {0x00583A4B,  3}, // InterfaceManager::Update
            {0x00583AE3,  3}, // InterfaceManager::Update
            {0x00583B59,  1}, // InterfaceManager::Update
            {0x00583C41,  2}, // InterfaceManager::UpdateAndExpireFadeTimers
            {0x0058430B,  2}, // FadeMenu
            {0x00584960,  1}, // Menu::Subroutine00584960
            {0x00585190,  1}, // Menu::EnableMenu
            {0x005866CC,  1}, // unknown; this is the subroutine that handles "reload [MenuName]" console commands
            {0x00589C27,  1}, // Tile::Value::~Value              // related to operators?
            {0x0058BF92,  1}, // Tile::Value::DoActionEnumeration
            {0x0058BFBC,  1}, // Tile::Value::DoActionEnumeration
            {0x0058C04C,  2}, // Tile::Value::DoActionEnumeration
            {0x0058C33E,  5}, // Tile::Value::DoActionEnumeration
            {0x0058C798,  1}, // Tile::Value::DoActionEnumeration
            {0x0058C7BA,  1}, // Tile::Value::DoActionEnumeration
            {0x0058C85F,  1}, // Tile::Value::DoActionEnumeration
            {0x0058CF66,  1}, // Tile::UpdateTemplatedChildren
            {0x0058D0F8,  1}, // Tile::UpdateTemplatedChildren
            {0x0058D1AC,  5}, // Tile::UpdateTemplatedChildren
            {0x0058D2F0,  2}, // Struct0058BCD0::AddTemplateItem
            {0x0058DC7C,  1}, // ParseXML
            {0x005A40D0,  1}, // unknown; likely ShowGenericMenu; definitely related to GenericMenu
            {0x005A68FF,  2}, // unknown; related to the Big Four; likely handles the switch to StatsMenu
         };

      void Apply() {
         _MESSAGE("Cleaning up after MenuQue patches... (Some leave broken bytes, which is harmless but will confuse a disassembler.)");
         for (UInt32 i = 0; i < std::extent<decltype(calls)>::value; i++) {
            UInt32 address = calls[i].address;
            char opcode = *(char*) address;
            if (opcode != (char) 0xE8 && opcode != (char) 0xE9) { // comparing without a cast compares as a UInt32, fucking hell
               _MESSAGE(" - MenuQue has not patched address %08X (detected opcode is %02X). Leaving it alone.", address, opcode);
               continue;
            }
            _MESSAGE(" - Writing NOPs near address %08X.", address);
            address += 5;
            UInt8 count = calls[i].brokenByteCount;
            SafeMemset(address, 0x90, count);
            g_detectedMenuQue = true;
         }
         _MESSAGE(" - All known patches have been looked at.");
         {  // Get the base address.
            UInt32 callFrom = 0x0058BFBC;
            if (*(char*)callFrom == (char)0xE9) {
               UInt32 a = *(UInt32*)(callFrom + 1);
               UInt32 t = a + callFrom + 1 + 4;
               g_detectedMenuQueBaseAddress = t - 0x00012040;
               _MESSAGE(" - MenuQue's base address reads as %08X based on the patch to %08X.", g_detectedMenuQueBaseAddress, callFrom);
            } else if (g_detectedMenuQue)
               _MESSAGE(" - Unable to identify MenuQue's base address! Some of our compatibility patches will not function!");
         }
      }
   }
}